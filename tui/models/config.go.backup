package models

import (
	"fmt"
	"strconv"
	"strings"

	"ztc-tui/colors"
	"ztc-tui/components"
	"ztc-tui/models/config_steps"
	"ztc-tui/utils"
	"ztc-tui/validation"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// ConfigStepModel interface alias from config_steps package
type ConfigStepModel = config_steps.ConfigStepModel

type ConfigModel struct {
	Width   int
	Height  int
	session *utils.Session

	// Template-based configuration
	templateID       string
	template         *utils.ClusterConfig
	templateMetadata *utils.TemplateMetadata

	// Configuration state
	currentStep   int
	steps         []string
	modeIndicator *components.ModeIndicator
	stepIndicator *components.StepIndicator

	// Collapsible sections for Advanced mode
	networkSection      *components.CollapsibleSection
	sshSection          *components.CollapsibleSection
	haSection           *components.CollapsibleSection
	currentSectionIndex int

	// Configuration steps (Phase 3: Sub-model orchestration)
	configSteps    []ConfigStepModel
	currentStepIdx int

	// UI state
	focusedField int
	fields       []string

	// Error state
	currentError   error
	schemaWarnings string
}

type ConfigInitMsg struct {
	Session    *utils.Session
	TemplateID string
}


// NewConfigModel creates a new template-based configuration model
func NewConfigModel() ConfigModel {
	return ConfigModel{
		Width:  80,
		Height: 24,
		steps: []string{
			"Template Preview",
			"Basic Customization",
			"Storage Configuration",
			"Bundle Selection",
			"Final Review",
		},
		currentStep:         0,
		focusedField:        0,
		currentSectionIndex: -1, // Initialize to -1 to indicate no section focused initially
	}
}

func (m ConfigModel) Init() tea.Cmd {
	return nil
}

func (m ConfigModel) Update(msg tea.Msg) (ConfigModel, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case ConfigInitMsg:
		m.session = msg.Session
		m.templateID = msg.TemplateID

		// Initialize mode indicator
		m.modeIndicator = components.NewModeIndicator(m.session.ConfigMode)

		// Set up different step flows based on configuration mode
		if m.session.ConfigMode == utils.ConfigModeSimple {
			m.steps = []string{
				"Essentials",
				"Network Essentials",
				"SSH Setup",
				"Deploy Preview",
			}
		} else {
			m.steps = []string{
				"Template Preview",
				"Basic Customization",
				"Storage Configuration",
				"Bundle Selection",
				"Final Review",
			}
		}

		// Initialize step indicator
		m.stepIndicator = components.NewStepIndicator(m.steps, m.currentStep)

		// Perform comprehensive schema health check first
		schemaHealthResult, err := utils.ValidateSchemaHealth()
		if err != nil {
			m.currentError = fmt.Errorf("Schema validation system error: %w", err)
			return m, nil
		}

		// Check for critical schema errors that prevent template loading
		if !schemaHealthResult.Valid {
			errorMessages := []string{"‚ùå Schema validation failed:"}
			for _, schemaErr := range schemaHealthResult.Errors {
				errorMessages = append(errorMessages, fmt.Sprintf("  ‚Ä¢ %s", schemaErr.Message))
				if schemaErr.Suggestion != "" {
					errorMessages = append(errorMessages, fmt.Sprintf("    üí° %s", schemaErr.Suggestion))
				}
			}
			m.currentError = fmt.Errorf("%s", strings.Join(errorMessages, "\n"))
			return m, nil
		}

		// Show schema warnings if present (non-blocking)
		if len(schemaHealthResult.Warnings) > 0 {
			m.schemaWarnings = schemaHealthResult.FormatWarnings()
		}

		// Load template for the selected template ID
		template, err := utils.LoadClusterTemplate(m.templateID)
		if err != nil {
			m.currentError = fmt.Errorf("Failed to load template: %w", err)
			return m, nil
		}

		// Validate template against schema
		templateValidationResult, err := utils.GetValidator().ValidateClusterConfig(template)
		if err != nil {
			m.currentError = fmt.Errorf("Template validation error: %w", err)
			return m, nil
		}

		if !templateValidationResult.Valid {
			errorMessages := []string{fmt.Sprintf("‚ùå Template '%s' validation failed:", m.templateID)}
			for _, validationErr := range templateValidationResult.Errors {
				errorMessages = append(errorMessages, fmt.Sprintf("  ‚Ä¢ %s: %s", validationErr.Field, validationErr.Message))
				if validationErr.Suggestion != "" {
					errorMessages = append(errorMessages, fmt.Sprintf("    üí° %s", validationErr.Suggestion))
				}
			}
			errorMessages = append(errorMessages, fmt.Sprintf("\nüìä Summary: %s", templateValidationResult.FormatSummary()))
			m.currentError = fmt.Errorf("%s", strings.Join(errorMessages, "\n"))
			return m, nil
		}

		m.template = template

		// Create metadata from template data (data-driven approach)
		metadata := &utils.TemplateMetadata{
			Name:        template.Cluster.Name,
			Description: template.Cluster.Description,
			NodeCount:   fmt.Sprintf("%d nodes", len(template.Nodes.ClusterNodes)),
			// Determine storage types from template
			StorageTypes: m.getStorageTypesFromTemplate(template),
		}
		m.templateMetadata = metadata



		// Initialize configuration steps (Phase 3: Step orchestration)
		m.initializeConfigSteps()
		return m, nil

	case tea.KeyMsg:
		// Handle errors first
		if m.currentError != nil {
			switch msg.String() {
			case "esc":
				return m, func() tea.Msg {
					return StateTransitionMsg{To: "welcome"}
				}
			case "q", "ctrl+c":
				return m, func() tea.Msg {
					return StateTransitionMsg{To: "quit"}
				}
			}
			return m, nil
		}

		switch msg.String() {
		case "enter":
			if m.currentStepIdx == len(m.configSteps)-1 {
				// Final step - save and continue
				if m.validateAllSteps() {
					if err := m.saveConfiguration(); err != nil {
						m.currentError = fmt.Errorf("Failed to save configuration: %w", err)
						return m, nil
					}
					m.currentError = nil // Clear error on successful save
					return m, func() tea.Msg {
						return StateTransitionMsg{To: "usb"}
					}
				}
				return m, nil
			}
			// Move to next step
			if m.validateCurrentStepModel() {
				if m.currentStepIdx < len(m.configSteps)-1 {
					m.currentStepIdx++
					if m.stepIndicator != nil {
						m.stepIndicator.SetCurrentStep(m.currentStepIdx)
					}
				}
			}
		case "left", "h":
			if m.currentStepIdx > 0 {
				m.currentStepIdx--
				if m.stepIndicator != nil {
					m.stepIndicator.SetCurrentStep(m.currentStepIdx)
				}
			}
		case "right", "l":
			if m.currentStepIdx < len(m.configSteps)-1 && m.validateCurrentStepModel() {
				m.currentStepIdx++
				if m.stepIndicator != nil {
					m.stepIndicator.SetCurrentStep(m.currentStepIdx)
				}
			}
		case "q", "ctrl+c":
			return m, func() tea.Msg {
				return StateTransitionMsg{To: "quit"}
			}
		case "esc":
			return m, func() tea.Msg {
				return StateTransitionMsg{To: "welcome"}
			}
		case "m", "M":
			// Toggle between Simple and Advanced modes
			if m.session != nil {
				if m.session.ConfigMode == utils.ConfigModeSimple {
					m.session.ConfigMode = utils.ConfigModeAdvanced
					// Switch to Advanced mode steps
					m.steps = []string{
						"Template Preview",
						"Basic Customization",
						"Storage Configuration",
						"Bundle Selection",
						"Final Review",
					}
					// Map current Simple step to appropriate Advanced step
					if m.currentStep >= 3 { // Deploy Preview -> Final Review
						m.currentStep = 4
					} else if m.currentStep >= 1 { // Network/SSH -> Basic Customization
						m.currentStep = 1
					} else { // Quick Setup -> Template Preview
						m.currentStep = 0
					}
				} else {
					m.session.ConfigMode = utils.ConfigModeSimple
					// Switch to Simple mode steps
					m.steps = []string{
						"Essentials",
						"Network Essentials",
						"SSH Setup",
						"Deploy Preview",
					}
					// Map current Advanced step to appropriate Simple step
					if m.currentStep >= 4 { // Final Review -> Deploy Preview
						m.currentStep = 3
					} else if m.currentStep >= 2 { // Storage/Bundle -> Deploy Preview
						m.currentStep = 3
					} else if m.currentStep >= 1 { // Basic Customization -> Network Essentials
						m.currentStep = 1
					} else { // Template Preview -> Essentials
						m.currentStep = 0
					}
				}
				// Update mode indicator and step indicator
				m.modeIndicator.SetMode(m.session.ConfigMode)
				m.stepIndicator.SetSteps(m.steps)
				m.stepIndicator.SetCurrentStep(m.currentStep)
				m.focusedField = 0
				m.setFocus()
			}
			return m, nil
		default:
			// Delegate all other input to the current step
			if m.currentStepIdx < len(m.configSteps) {
				var updatedStep tea.Model
				updatedStep, cmd = m.configSteps[m.currentStepIdx].Update(msg)
				m.configSteps[m.currentStepIdx] = updatedStep.(ConfigStepModel)
				if cmd != nil {
					cmds = append(cmds, cmd)
				}
			}
		}
	}

	return m, tea.Batch(cmds...)
}

func (m ConfigModel) View() string {
	var content strings.Builder

	// Handle errors
	if m.currentError != nil {
		title := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF6600")).
			Bold(true).
			Render("Configuration Error")

		content.WriteString(title + "\n\n")
		content.WriteString(fmt.Sprintf("Error: %s\n\n", m.currentError.Error()))
		content.WriteString("Press Esc to go back or q to quit.\n")
		return content.String()
	}

	// Show schema warnings if present (non-blocking)
	if m.schemaWarnings != "" {
		warningTitle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFAA00")).
			Bold(true).
			Render("‚ö†Ô∏è Schema Warnings")

		content.WriteString(warningTitle + "\n\n")
		content.WriteString(m.schemaWarnings + "\n")
		content.WriteString("These warnings don't prevent configuration but may indicate template issues.\n\n")
	}

	// Enhanced title with mission name and visual separator
	missionName := "Unknown Mission"
	if m.templateMetadata != nil {
		missionName = m.templateMetadata.Name
	}

	titleStyle := lipgloss.NewStyle().
		Foreground(colors.ZtcOrange).
		Bold(true).
		Border(lipgloss.NormalBorder(), false, false, true, false).
		BorderForeground(colors.ZtcLightGray).
		PaddingBottom(1).
		MarginBottom(1)

	title := titleStyle.Render(fmt.Sprintf("üèóÔ∏è  Configure %s", missionName))
	content.WriteString(title + "\n")

	// Mode indicator
	if m.modeIndicator != nil {
		content.WriteString(m.modeIndicator.Compact() + "\n\n")
	}

	// Steps indicator
	if m.stepIndicator != nil {
		content.WriteString(m.stepIndicator.View() + "\n\n")
	}

	// Current step content
	stepContent := m.renderCurrentStep()
	content.WriteString(stepContent + "\n\n")

	// Enhanced navigation help with visual separation
	helpText := m.getHelpText()
	helpStyle := lipgloss.NewStyle().
		Foreground(colors.ZtcMutedGray).
		Border(lipgloss.NormalBorder(), true, false, false, false).
		BorderForeground(colors.ZtcLightGray).
		PaddingTop(1).
		MarginTop(1)

	help := helpStyle.Render(fmt.Sprintf("‚å®Ô∏è  %s", helpText))
	content.WriteString(help)

	return content.String()
}

func (m ConfigModel) getHelpText() string {
	baseHelp := "M Switch Mode ‚Ä¢ Esc Back ‚Ä¢ q Quit"

	if m.session != nil && m.session.ConfigMode == utils.ConfigModeSimple {
		// Simple mode help text
		switch m.currentStep {
		case 0: // Quick Setup
			return "Tab/‚Üë‚Üì Navigate ‚Ä¢ Type to edit ‚Ä¢ Enter Next ‚Ä¢ " + baseHelp
		case 1: // Network Essentials
			return "Tab/‚Üë‚Üì Navigate ‚Ä¢ Type to edit ‚Ä¢ Enter Next ‚Ä¢ ‚Üê Previous ‚Ä¢ " + baseHelp
		case 2: // SSH Setup
			return "Tab/‚Üë‚Üì Navigate ‚Ä¢ Type to edit ‚Ä¢ Enter Next ‚Ä¢ ‚Üê Previous ‚Ä¢ " + baseHelp
		case 3: // Deploy Preview
			return "Enter Save & Continue ‚Ä¢ ‚Üê Previous ‚Ä¢ " + baseHelp
		default:
			return "‚Üê ‚Üí Navigate steps ‚Ä¢ Enter Continue ‚Ä¢ " + baseHelp
		}
	} else {
		// Advanced mode help text
		switch m.currentStep {
		case 0: // Template Preview
			return "Enter Next step ‚Ä¢ " + baseHelp
		case 1: // Basic Customization
			return "Tab/‚Üë‚Üì Navigate sections ‚Ä¢ Space Toggle ‚Ä¢ Type to edit ‚Ä¢ Enter Next step ‚Ä¢ ‚Üê Previous ‚Ä¢ " + baseHelp
		case 2: // Storage Configuration
			return "Tab/‚Üë‚Üì Navigate fields ‚Ä¢ Enter/Space Toggle ‚Ä¢ Type to edit ‚Ä¢ Enter Next step ‚Ä¢ ‚Üê Previous ‚Ä¢ " + baseHelp
		case 3: // Bundle Selection
			return "Tab/‚Üë‚Üì Navigate bundles ‚Ä¢ Enter/Space Toggle ‚Ä¢ Enter Next step ‚Ä¢ ‚Üê Previous ‚Ä¢ " + baseHelp
		case 4: // Final Review
			return "Enter Save & Continue ‚Ä¢ ‚Üê Previous ‚Ä¢ " + baseHelp
		default:
			return "‚Üê ‚Üí Navigate steps ‚Ä¢ Enter Continue ‚Ä¢ " + baseHelp
		}
	}
}

func (m ConfigModel) renderCurrentStep() string {
	// Phase 3: Delegate rendering to current step model
	if m.currentStepIdx < len(m.configSteps) {
		currentStep := m.configSteps[m.currentStepIdx]
		
		// Only show steps that should be visible in current mode
		if m.session != nil && currentStep.ShouldShow(m.session.ConfigMode) {
			return currentStep.View()
		}
		
		// Skip steps that shouldn't be shown and move to next
		if m.currentStepIdx < len(m.configSteps)-1 {
			m.currentStepIdx++
			return m.renderCurrentStep()
		}
	}
	
	return "No available steps for current configuration mode"
}

func (m ConfigModel) renderTemplatePreview() string {
	content := strings.Builder{}

	content.WriteString("Template Preview\n")
	content.WriteString("===============\n\n")

	if m.templateMetadata == nil {
		content.WriteString("Loading template...")
		return content.String()
	}

	// Mission overview
	content.WriteString(fmt.Sprintf("Mission: %s\n", m.templateMetadata.Name))
	content.WriteString(fmt.Sprintf("Description: %s\n\n", m.templateMetadata.Description))

	// Hardware requirements
	content.WriteString("Hardware Requirements:\n")
	content.WriteString(fmt.Sprintf("‚Ä¢ Node Count: %s\n", m.templateMetadata.NodeCount))
	content.WriteString(fmt.Sprintf("‚Ä¢ Resources: %s\n", m.templateMetadata.HardwareReq))
	content.WriteString(fmt.Sprintf("‚Ä¢ Architecture: %s\n\n", m.templateMetadata.Architecture))

	// Storage strategy
	content.WriteString("Storage Types:\n")
	for _, storageType := range m.templateMetadata.StorageTypes {
		content.WriteString(fmt.Sprintf("‚Ä¢ %s\n", storageType))
	}
	content.WriteString("\n")

	// Use cases and trade-offs
	content.WriteString("Perfect for:\n")
	for _, useCase := range m.templateMetadata.UseCases {
		content.WriteString(fmt.Sprintf("‚Ä¢ %s\n", useCase))
	}
	content.WriteString("\n")

	if len(m.templateMetadata.TradeOffs) > 0 {
		content.WriteString("Trade-offs:\n")
		for _, tradeOff := range m.templateMetadata.TradeOffs {
			content.WriteString(fmt.Sprintf("‚Ä¢ %s\n", tradeOff))
		}
		content.WriteString("\n")
	}

	content.WriteString("This template will be loaded and ready for customization.\n")

	return content.String()
}

func (m ConfigModel) renderBasicCustomization() string {
	content := strings.Builder{}

	content.WriteString("Advanced Configuration\n")
	content.WriteString("=====================\n\n")

	// Cluster name (always visible) - DEPRECATED: Now handled by sub-models
	// if m.clusterNameInput != nil {
	//	content.WriteString(m.clusterNameInput.View())
	//	content.WriteString("\n\n")
	// }

	// Initialize sections if not done yet
	m.initializeCollapsibleSections()

	// Render collapsible sections
	content.WriteString("Use Space/Enter to expand sections, Tab/‚Üë‚Üì to navigate between sections:\n\n")

	if m.networkSection != nil {
		content.WriteString(m.networkSection.View())
		content.WriteString("\n")
	}

	if m.sshSection != nil {
		content.WriteString(m.sshSection.View())
		content.WriteString("\n")
	}

	// Show HA section only if enabled or available in template
	if m.haSection != nil && (m.hasHAInTemplate() || (m.enableHAToggle != nil && m.enableHAToggle.GetValue())) {
		content.WriteString(m.haSection.View())
		content.WriteString("\n")
	}

	content.WriteString("\nüí° Use Space/Enter to toggle sections, Tab/‚Üë‚Üì to navigate\n")

	return content.String()
}

// getSections returns a list of available sections
func (m *ConfigModel) getSections() []*components.CollapsibleSection {
	var sections []*components.CollapsibleSection
	if m.networkSection != nil {
		sections = append(sections, m.networkSection)
	}
	if m.sshSection != nil {
		sections = append(sections, m.sshSection)
	}
	if m.haSection != nil && (m.hasHAInTemplate() || (m.enableHAToggle != nil && m.enableHAToggle.GetValue())) {
		sections = append(sections, m.haSection)
	}
	return sections
}

// nextSection moves focus to the next collapsible section
func (m *ConfigModel) nextSection() {
	sections := m.getSections()
	if len(sections) == 0 {
		return
	}

	// Clear current section focus
	if m.currentSectionIndex >= 0 && m.currentSectionIndex < len(sections) {
		sections[m.currentSectionIndex].SetFocused(false)
	}

	// Move to next section
	m.currentSectionIndex++
	if m.currentSectionIndex >= len(sections) {
		m.currentSectionIndex = 0
	}

	// Set new section focus
	if m.currentSectionIndex < len(sections) {
		sections[m.currentSectionIndex].SetFocused(true)
	}
}

// prevSection moves focus to the previous collapsible section
func (m *ConfigModel) prevSection() {
	sections := m.getSections()
	if len(sections) == 0 {
		return
	}

	// Clear current section focus
	if m.currentSectionIndex >= 0 && m.currentSectionIndex < len(sections) {
		sections[m.currentSectionIndex].SetFocused(false)
	}

	// Move to previous section
	m.currentSectionIndex--
	if m.currentSectionIndex < 0 {
		m.currentSectionIndex = len(sections) - 1
	}

	// Set new section focus
	if m.currentSectionIndex < len(sections) {
		sections[m.currentSectionIndex].SetFocused(true)
	}
}

// toggleCurrentSection toggles the currently focused section
func (m *ConfigModel) toggleCurrentSection() {
	sections := m.getSections()
	if len(sections) == 0 {
		return
	}

	if m.currentSectionIndex >= 0 && m.currentSectionIndex < len(sections) {
		sections[m.currentSectionIndex].Toggle()
	}
}

// initializeCollapsibleSections creates collapsible sections for advanced mode
func (m *ConfigModel) initializeCollapsibleSections() {
	// Always refresh content to ensure it's up to date

	// Network Configuration Section
	var networkContent strings.Builder
	if m.networkSubnetInput != nil {
		networkContent.WriteString(m.networkSubnetInput.View())
		networkContent.WriteString("\n\n")
	}
	if m.gatewayInput != nil {
		networkContent.WriteString(m.gatewayInput.View())
		networkContent.WriteString("\n\n")
	}
	if m.podCIDRInput != nil {
		networkContent.WriteString(m.podCIDRInput.View())
		networkContent.WriteString("\n\n")
	}
	if m.serviceCIDRInput != nil {
		networkContent.WriteString(m.serviceCIDRInput.View())
		networkContent.WriteString("\n\n")
	}
	if m.dnsDomainInput != nil {
		networkContent.WriteString(m.dnsDomainInput.View())
		networkContent.WriteString("\n\n")
	}
	if m.dnsUpstreamsInput != nil {
		networkContent.WriteString(m.dnsUpstreamsInput.View())
		networkContent.WriteString("\n")
	}
	m.networkSection = components.NewCollapsibleSection("üåê Network Configuration", networkContent.String(), false)

	// SSH Configuration Section
	var sshContent strings.Builder
	if m.sshPublicKeyInput != nil {
		sshContent.WriteString(m.sshPublicKeyInput.View())
		sshContent.WriteString("\n\n")
	}
	if m.sshPrivateKeyInput != nil {
		sshContent.WriteString(m.sshPrivateKeyInput.View())
		sshContent.WriteString("\n\n")
	}
	if m.sshUsernameInput != nil {
		sshContent.WriteString(m.sshUsernameInput.View())
		sshContent.WriteString("\n")
	}
	m.sshSection = components.NewCollapsibleSection("üîë SSH Configuration", sshContent.String(), false)

	// High Availability Section (if available)
	if m.hasHAInTemplate() || (m.enableHAToggle != nil && m.enableHAToggle.GetValue()) {
		var haContent strings.Builder
		if m.haEnabledToggle != nil {
			haContent.WriteString(m.haEnabledToggle.View())
			haContent.WriteString("\n\n")
		}
		if m.haVirtualIPInput != nil {
			haContent.WriteString(m.haVirtualIPInput.View())
			haContent.WriteString("\n\n")
		}
		if m.haLoadBalancerTypeSelect != nil {
			haContent.WriteString(m.haLoadBalancerTypeSelect.View())
			haContent.WriteString("\n")
		}
		m.haSection = components.NewCollapsibleSection("‚ö° High Availability", haContent.String(), false)
	}

	// Set initial focus to first section if not already set
	if m.currentSectionIndex < 0 && m.networkSection != nil {
		m.networkSection.SetFocused(true)
		m.currentSectionIndex = 0
	} else if m.currentSectionIndex >= 0 {
		// Restore focus to current section
		sections := m.getSections()
		if m.currentSectionIndex < len(sections) {
			sections[m.currentSectionIndex].SetFocused(true)
		}
	}
}

func (m ConfigModel) renderBundleSelection() string {
	content := strings.Builder{}

	content.WriteString("Workload Bundles\n")
	content.WriteString("===============\n\n")
	content.WriteString("Choose applications to auto-deploy after cluster setup:\n\n")

	if len(m.availableBundles) == 0 {
		content.WriteString("No bundles available for this mission.\n")
		return content.String()
	}

	// Render bundle toggles
	for _, bundle := range m.availableBundles {
		if toggle, exists := m.bundleToggles[bundle.ID]; exists {
			content.WriteString(toggle.View())
			content.WriteString("\n")
		}
	}

	content.WriteString("\nBundles can be deployed later using 'make deploy-bundle-<name>' commands.\n")

	return content.String()
}

func (m ConfigModel) renderFinalReview() string {
	content := strings.Builder{}

	content.WriteString("Final Review\n")
	content.WriteString("===========\n\n")

	if m.templateMetadata != nil {
		content.WriteString(fmt.Sprintf("Mission: %s\n", m.templateMetadata.Name))
	}

	if m.clusterNameInput != nil {
		content.WriteString(fmt.Sprintf("Cluster Name: %s\n", m.clusterNameInput.GetValue()))
	}

	if m.networkSubnetInput != nil {
		content.WriteString(fmt.Sprintf("Network Subnet: %s\n", m.networkSubnetInput.GetValue()))
	}

	if m.gatewayInput != nil {
		content.WriteString(fmt.Sprintf("Gateway: %s\n", m.gatewayInput.GetValue()))
	}

	if m.podCIDRInput != nil {
		content.WriteString(fmt.Sprintf("Pod CIDR: %s\n", m.podCIDRInput.GetValue()))
	}

	if m.serviceCIDRInput != nil {
		content.WriteString(fmt.Sprintf("Service CIDR: %s\n", m.serviceCIDRInput.GetValue()))
	}

	if m.dnsDomainInput != nil {
		content.WriteString(fmt.Sprintf("DNS Domain: %s\n", m.dnsDomainInput.GetValue()))
	}

	if m.dnsUpstreamsInput != nil && m.dnsUpstreamsInput.GetValue() != "" {
		content.WriteString(fmt.Sprintf("DNS Upstreams: %s\n", m.dnsUpstreamsInput.GetValue()))
	}

	// Show SSH configuration
	content.WriteString("\nSSH Configuration:\n")
	if m.sshPublicKeyInput != nil {
		content.WriteString(fmt.Sprintf("SSH Public Key: %s\n", m.sshPublicKeyInput.GetValue()))
	}
	if m.sshPrivateKeyInput != nil {
		content.WriteString(fmt.Sprintf("SSH Private Key: %s\n", m.sshPrivateKeyInput.GetValue()))
	}
	if m.sshUsernameInput != nil {
		content.WriteString(fmt.Sprintf("SSH Username: %s\n", m.sshUsernameInput.GetValue()))
	}

	// Show HA configuration (if available)
	if m.hasHAConfiguration() && m.haEnabledToggle != nil {
		content.WriteString("\nHigh Availability Configuration:\n")
		content.WriteString(fmt.Sprintf("HA Enabled: %t\n", m.haEnabledToggle.GetValue()))

		if m.haEnabledToggle.GetValue() {
			if m.haVirtualIPInput != nil {
				content.WriteString(fmt.Sprintf("Virtual IP: %s\n", m.haVirtualIPInput.GetValue()))
			}
			if m.haLoadBalancerTypeSelect != nil {
				content.WriteString(fmt.Sprintf("Load Balancer Type: %s\n", m.haLoadBalancerTypeSelect.GetValue()))
			}
			if m.haLoadBalancerPortInput != nil && m.haLoadBalancerPortInput.GetValue() != "" {
				content.WriteString(fmt.Sprintf("Load Balancer Port: %s\n", m.haLoadBalancerPortInput.GetValue()))
			}
			if m.haEtcdSnapshotCountInput != nil && m.haEtcdSnapshotCountInput.GetValue() != "" {
				content.WriteString(fmt.Sprintf("Etcd Snapshot Count: %s\n", m.haEtcdSnapshotCountInput.GetValue()))
			}
			if m.haEtcdHeartbeatInput != nil && m.haEtcdHeartbeatInput.GetValue() != "" {
				content.WriteString(fmt.Sprintf("Etcd Heartbeat Interval: %s\n", m.haEtcdHeartbeatInput.GetValue()))
			}
		}
	}

	// Show storage configuration
	content.WriteString("\nStorage Configuration:\n")
	if m.storageDefaultClassSelect != nil {
		content.WriteString(fmt.Sprintf("Default Storage Class: %s\n", m.storageDefaultClassSelect.GetValue()))
	}

	if m.localPathEnabledToggle != nil && m.localPathEnabledToggle.GetValue() {
		content.WriteString("LocalPath: Enabled\n")
	}

	if m.longhornEnabledToggle != nil && m.longhornEnabledToggle.GetValue() {
		content.WriteString("Longhorn: Enabled")
		if m.longhornReplicaCountInput != nil {
			content.WriteString(fmt.Sprintf(" (Replicas: %s)", m.longhornReplicaCountInput.GetValue()))
		}
		content.WriteString("\n")
	}

	if m.nfsEnabledToggle != nil && m.nfsEnabledToggle.GetValue() {
		content.WriteString("NFS: Enabled")
		if m.nfsStorageSizeInput != nil {
			content.WriteString(fmt.Sprintf(" (Size: %s)", m.nfsStorageSizeInput.GetValue()))
		}
		content.WriteString("\n")
	}

	// Show selected bundles
	var selectedBundles []string
	for _, bundle := range m.availableBundles {
		if toggle, exists := m.bundleToggles[bundle.ID]; exists && toggle.GetValue() {
			selectedBundles = append(selectedBundles, bundle.Name)
		}
	}

	if len(selectedBundles) > 0 {
		content.WriteString(fmt.Sprintf("Auto-Deploy Bundles: %s\n", strings.Join(selectedBundles, ", ")))
	} else {
		content.WriteString("Auto-Deploy Bundles: None\n")
	}

	content.WriteString("\n")

	// Show node information
	if m.template != nil {
		content.WriteString("Nodes:\n")
		for hostname, node := range m.template.Nodes.ClusterNodes {
			content.WriteString(fmt.Sprintf("‚Ä¢ %s: %s (%s)\n", hostname, node.IP, node.Role))
		}
		content.WriteString("\n")
	}

	content.WriteString("Configuration ready!\n")

	content.WriteString("Press Enter to continue to USB creation.\n")

	return content.String()
}

// Simple mode step fields: Essentials, Network Essentials, SSH Setup, Deploy Preview
var simpleStepFields = [][]string{
	{"clusterName"}, // Essentials - cluster name only
	{"networkSubnet", "gateway", "dnsDomain"}, // Network Essentials - core network settings
	{"sshPublicKey", "sshUsername"},           // SSH Setup - essential SSH configuration
	{},                                        // Deploy Preview - no fields (read-only)
}

// Advanced mode step fields: Template Preview, Basic Customization, Storage Configuration, Bundle Selection, Final Review
var advancedStepFields = [][]string{
	{}, // Template Preview - no fields (read-only)
	{"clusterName", "networkSubnet", "gateway", "podCIDR", "serviceCIDR", "dnsDomain", "dnsUpstreams", "sshPublicKey", "sshPrivateKey", "sshUsername", "enableHA", "haEnabled", "haVirtualIP", "haLoadBalancerType", "haLoadBalancerPort", "haEtcdSnapshotCount", "haEtcdHeartbeat"}, // Basic Customization
	{}, // Storage Configuration - dynamic fields based on enabled providers
	{}, // Bundle Selection - dynamic fields based on available bundles
	{}, // Final Review - no fields (read-only)
}

// Helper methods for focus management
func (m *ConfigModel) setFocus() {
	// Clear all focus first
	if m.clusterNameInput != nil {
		m.clusterNameInput.Blur()
	}
	if m.networkSubnetInput != nil {
		m.networkSubnetInput.Blur()
	}
	if m.gatewayInput != nil {
		m.gatewayInput.Blur()
	}
	if m.podCIDRInput != nil {
		m.podCIDRInput.Blur()
	}
	if m.serviceCIDRInput != nil {
		m.serviceCIDRInput.Blur()
	}
	if m.dnsDomainInput != nil {
		m.dnsDomainInput.Blur()
	}
	if m.dnsUpstreamsInput != nil {
		m.dnsUpstreamsInput.Blur()
	}
	if m.sshPublicKeyInput != nil {
		m.sshPublicKeyInput.Blur()
	}
	if m.sshPrivateKeyInput != nil {
		m.sshPrivateKeyInput.Blur()
	}
	if m.sshUsernameInput != nil {
		m.sshUsernameInput.Blur()
	}

	// Blur HA fields
	if m.haEnabledToggle != nil {
		m.haEnabledToggle.Blur()
	}
	if m.haVirtualIPInput != nil {
		m.haVirtualIPInput.Blur()
	}
	if m.haLoadBalancerTypeSelect != nil {
		m.haLoadBalancerTypeSelect.Blur()
	}
	if m.haLoadBalancerPortInput != nil {
		m.haLoadBalancerPortInput.Blur()
	}
	if m.haEtcdSnapshotCountInput != nil {
		m.haEtcdSnapshotCountInput.Blur()
	}
	if m.haEtcdHeartbeatInput != nil {
		m.haEtcdHeartbeatInput.Blur()
	}

	// Blur feature enablement toggles
	if m.enableHAToggle != nil {
		m.enableHAToggle.Blur()
	}
	for _, toggle := range m.bundleToggles {
		toggle.Blur()
	}

	// Get the appropriate step fields based on configuration mode
	var stepFields [][]string
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeSimple {
		stepFields = simpleStepFields
	} else {
		stepFields = advancedStepFields
	}

	// Handle different steps
	if m.currentStep >= len(stepFields) {
		return
	}

	// For Advanced mode, skip steps 0 and 4 (Template Preview and Final Review)
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeAdvanced && (m.currentStep == 0 || m.currentStep == 4) {
		return
	}

	// Get fields for current step
	fields := stepFields[m.currentStep]
	if len(fields) == 0 || m.focusedField >= len(fields) {
		return
	}

	fieldToFocus := fields[m.focusedField]
	switch fieldToFocus {
	case "clusterName":
		if m.clusterNameInput != nil {
			m.clusterNameInput.Focus()
		}
	case "networkSubnet":
		if m.networkSubnetInput != nil {
			m.networkSubnetInput.Focus()
		}
	case "gateway":
		if m.gatewayInput != nil {
			m.gatewayInput.Focus()
		}
	case "podCIDR":
		if m.podCIDRInput != nil {
			m.podCIDRInput.Focus()
		}
	case "serviceCIDR":
		if m.serviceCIDRInput != nil {
			m.serviceCIDRInput.Focus()
		}
	case "dnsDomain":
		if m.dnsDomainInput != nil {
			m.dnsDomainInput.Focus()
		}
	case "dnsUpstreams":
		if m.dnsUpstreamsInput != nil {
			m.dnsUpstreamsInput.Focus()
		}
	case "sshPublicKey":
		if m.sshPublicKeyInput != nil {
			m.sshPublicKeyInput.Focus()
		}
	case "sshPrivateKey":
		if m.sshPrivateKeyInput != nil {
			m.sshPrivateKeyInput.Focus()
		}
	case "sshUsername":
		if m.sshUsernameInput != nil {
			m.sshUsernameInput.Focus()
		}
	case "haEnabled":
		if m.haEnabledToggle != nil {
			m.haEnabledToggle.Focus()
		}
	case "haVirtualIP":
		if m.haVirtualIPInput != nil {
			m.haVirtualIPInput.Focus()
		}
	case "haLoadBalancerType":
		if m.haLoadBalancerTypeSelect != nil {
			m.haLoadBalancerTypeSelect.Focus()
		}
	case "haLoadBalancerPort":
		if m.haLoadBalancerPortInput != nil {
			m.haLoadBalancerPortInput.Focus()
		}
	case "haEtcdSnapshotCount":
		if m.haEtcdSnapshotCountInput != nil {
			m.haEtcdSnapshotCountInput.Focus()
		}
	case "haEtcdHeartbeat":
		if m.haEtcdHeartbeatInput != nil {
			m.haEtcdHeartbeatInput.Focus()
		}
	case "enableHA":
		if m.enableHAToggle != nil {
			m.enableHAToggle.Focus()
		}
	}

	// Handle special cases for Advanced mode dynamic fields
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeAdvanced {
		switch m.currentStep {
		case 2: // Storage Configuration
			if m.focusedField < m.getStorageFieldCount() {
				m.focusStorageField(m.focusedField)
			}
			return
		case 3: // Bundle Selection
			if m.focusedField < len(m.availableBundles) {
				bundleID := m.availableBundles[m.focusedField].ID
				if toggle, ok := m.bundleToggles[bundleID]; ok {
					toggle.Focus()
				}
			}
			return
		}
	}
}

func (m *ConfigModel) nextField() {
	// Get the appropriate step fields based on configuration mode
	var stepFields [][]string
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeSimple {
		stepFields = simpleStepFields
	} else {
		stepFields = advancedStepFields
	}

	// Handle step bounds and get field count
	if m.currentStep >= len(stepFields) {
		return
	}

	var maxFields int
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeAdvanced {
		switch m.currentStep {
		case 0, 4: // Template Preview and Final Review - no fields
			return
		case 2: // Storage Configuration
			maxFields = m.getStorageFieldCount()
		case 3: // Bundle Selection
			maxFields = len(m.availableBundles)
		default:
			maxFields = len(stepFields[m.currentStep])
		}
	} else {
		// Simple mode - use step fields directly
		maxFields = len(stepFields[m.currentStep])
	}

	if maxFields > 0 && m.focusedField < maxFields-1 {
		m.focusedField++
		m.setFocus()
	}
}

func (m *ConfigModel) prevField() {
	if m.focusedField > 0 {
		m.focusedField--
		m.setFocus()
	}
}

func (m *ConfigModel) updateFocusedField(msg tea.Msg) tea.Cmd {
	// Get the appropriate step fields based on configuration mode
	var stepFields [][]string
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeSimple {
		stepFields = simpleStepFields
	} else {
		stepFields = advancedStepFields
	}

	// Handle step bounds
	if m.currentStep >= len(stepFields) {
		return nil
	}

	// For Advanced mode, skip steps with no interaction
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeAdvanced && (m.currentStep == 0 || m.currentStep == 4) {
		return nil
	}

	// Handle special Advanced mode steps first
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeAdvanced {
		switch m.currentStep {
		case 2: // Storage Configuration
			return m.updateStorageField(m.focusedField, msg)
		case 3: // Bundle Selection  
			if m.focusedField < len(m.availableBundles) {
				bundleID := m.availableBundles[m.focusedField].ID
				if toggle, ok := m.bundleToggles[bundleID]; ok {
					return toggle.Update(msg)
				}
			}
			return nil
		}
	}

	// Handle regular step fields
	fields := stepFields[m.currentStep]
	if len(fields) == 0 || m.focusedField >= len(fields) {
		return nil
	}

	fieldToUpdate := fields[m.focusedField]
	switch fieldToUpdate {
	case "clusterName":
		if m.clusterNameInput != nil {
			return m.clusterNameInput.Update(msg)
		}
	case "networkSubnet":
		if m.networkSubnetInput != nil {
			return m.networkSubnetInput.Update(msg)
		}
	case "gateway":
		if m.gatewayInput != nil {
			return m.gatewayInput.Update(msg)
		}
	case "podCIDR":
		if m.podCIDRInput != nil {
			return m.podCIDRInput.Update(msg)
		}
	case "serviceCIDR":
		if m.serviceCIDRInput != nil {
			return m.serviceCIDRInput.Update(msg)
		}
	case "dnsDomain":
		if m.dnsDomainInput != nil {
			return m.dnsDomainInput.Update(msg)
		}
	case "dnsUpstreams":
		if m.dnsUpstreamsInput != nil {
			return m.dnsUpstreamsInput.Update(msg)
		}
	case "sshPublicKey":
		if m.sshPublicKeyInput != nil {
			return m.sshPublicKeyInput.Update(msg)
		}
	case "sshPrivateKey":
		if m.sshPrivateKeyInput != nil {
			return m.sshPrivateKeyInput.Update(msg)
		}
	case "sshUsername":
		if m.sshUsernameInput != nil {
			return m.sshUsernameInput.Update(msg)
		}
	case "haEnabled":
		if m.haEnabledToggle != nil {
			return m.haEnabledToggle.Update(msg)
		}
	case "haVirtualIP":
		if m.haVirtualIPInput != nil {
			return m.haVirtualIPInput.Update(msg)
		}
	case "haLoadBalancerType":
		if m.haLoadBalancerTypeSelect != nil {
			return m.haLoadBalancerTypeSelect.Update(msg)
		}
	case "haLoadBalancerPort":
		if m.haLoadBalancerPortInput != nil {
			return m.haLoadBalancerPortInput.Update(msg)
		}
	case "haEtcdSnapshotCount":
		if m.haEtcdSnapshotCountInput != nil {
			return m.haEtcdSnapshotCountInput.Update(msg)
		}
	case "haEtcdHeartbeat":
		if m.haEtcdHeartbeatInput != nil {
			return m.haEtcdHeartbeatInput.Update(msg)
		}
	case "enableHA":
		if m.enableHAToggle != nil {
			cmd := m.enableHAToggle.Update(msg)
			// When HA is enabled/disabled, re-initialize HA fields
			if m.enableHAToggle.GetValue() {
				m.initializeHAFields()
			}
			return cmd
		}
	}
	return nil
}

func (m *ConfigModel) validateCurrentStep() bool {
	if m.session != nil && m.session.ConfigMode == utils.ConfigModeSimple {
		// Simple mode validation
		return m.validateSimpleModeStep()
	} else {
		// Advanced mode validation (existing logic)
		return m.validateAdvancedModeStep()
	}
}

func (m *ConfigModel) validateSimpleModeStep() bool {
	switch m.currentStep {
	case 0: // Quick Setup
		// Validate cluster name
		return m.clusterNameInput != nil && m.clusterNameInput.ValidateInput()
	case 1: // Network Essentials
		// Validate network settings
		valid := true
		if m.networkSubnetInput != nil && !m.networkSubnetInput.ValidateInput() {
			valid = false
		}
		if m.gatewayInput != nil && !m.gatewayInput.ValidateInput() {
			valid = false
		}
		return valid
	case 2: // SSH Setup
		// Validate SSH configuration
		valid := true
		if m.sshPublicKeyInput != nil && !m.sshPublicKeyInput.ValidateInput() {
			valid = false
		}
		if m.sshPrivateKeyInput != nil && !m.sshPrivateKeyInput.ValidateInput() {
			valid = false
		}
		if m.sshUsernameInput != nil && !m.sshUsernameInput.ValidateInput() {
			valid = false
		}
		return valid
	case 3: // Deploy Preview - no validation needed
		return true
	default:
		return true
	}
}

func (m *ConfigModel) validateAdvancedModeStep() bool {
	switch m.currentStep {
	case 0: // Template Preview - no validation needed
		return true
	case 1: // Basic Customization
		valid := true
		if m.clusterNameInput != nil && !m.clusterNameInput.ValidateInput() {
			valid = false
		}
		if m.networkSubnetInput != nil && !m.networkSubnetInput.ValidateInput() {
			valid = false
		}
		if m.gatewayInput != nil && !m.gatewayInput.ValidateInput() {
			valid = false
		}
		if m.podCIDRInput != nil && !m.podCIDRInput.ValidateInput() {
			valid = false
		}
		if m.serviceCIDRInput != nil && !m.serviceCIDRInput.ValidateInput() {
			valid = false
		}
		if m.dnsDomainInput != nil && !m.dnsDomainInput.ValidateInput() {
			valid = false
		}
		if m.dnsUpstreamsInput != nil && !m.dnsUpstreamsInput.ValidateInput() {
			valid = false
		}
		if m.sshPublicKeyInput != nil && !m.sshPublicKeyInput.ValidateInput() {
			valid = false
		}
		if m.sshPrivateKeyInput != nil && !m.sshPrivateKeyInput.ValidateInput() {
			valid = false
		}
		if m.sshUsernameInput != nil && !m.sshUsernameInput.ValidateInput() {
			valid = false
		}

		// Validate HA fields (if available)
		if m.haVirtualIPInput != nil && !m.haVirtualIPInput.ValidateInput() {
			valid = false
		}
		if m.haLoadBalancerPortInput != nil && !m.haLoadBalancerPortInput.ValidateInput() {
			valid = false
		}
		if m.haEtcdSnapshotCountInput != nil && !m.haEtcdSnapshotCountInput.ValidateInput() {
			valid = false
		}
		if m.haEtcdHeartbeatInput != nil && !m.haEtcdHeartbeatInput.ValidateInput() {
			valid = false
		}

		// Cross-field network validation
		if valid {
			if err := m.validateNetworkConfiguration(); err != nil {
				// Set error on the most relevant field
				if m.gatewayInput != nil && strings.Contains(err.Error(), "gateway") {
					m.gatewayInput.ValidateInput() // This will trigger and show the error
				}
				valid = false
			}
		}
		return valid
	case 2: // Storage Configuration - validate enabled storage providers
		return m.validateStorageConfiguration()
	case 3: // Bundle Selection - no validation needed (optional)
		return true
	case 4: // Final Review - no validation needed
		return true
	}
	return true
}

func (m *ConfigModel) validateAllFields() bool {
	valid := true

	if m.clusterNameInput != nil && !m.clusterNameInput.ValidateInput() {
		valid = false
	}
	if m.networkSubnetInput != nil && !m.networkSubnetInput.ValidateInput() {
		valid = false
	}
	if m.gatewayInput != nil && !m.gatewayInput.ValidateInput() {
		valid = false
	}
	if m.podCIDRInput != nil && !m.podCIDRInput.ValidateInput() {
		valid = false
	}
	if m.serviceCIDRInput != nil && !m.serviceCIDRInput.ValidateInput() {
		valid = false
	}
	if m.dnsDomainInput != nil && !m.dnsDomainInput.ValidateInput() {
		valid = false
	}
	if m.dnsUpstreamsInput != nil && !m.dnsUpstreamsInput.ValidateInput() {
		valid = false
	}
	if m.sshPublicKeyInput != nil && !m.sshPublicKeyInput.ValidateInput() {
		valid = false
	}
	if m.sshPrivateKeyInput != nil && !m.sshPrivateKeyInput.ValidateInput() {
		valid = false
	}
	if m.sshUsernameInput != nil && !m.sshUsernameInput.ValidateInput() {
		valid = false
	}

	// Validate HA fields (if available)
	if m.haVirtualIPInput != nil && !m.haVirtualIPInput.ValidateInput() {
		valid = false
	}
	if m.haLoadBalancerPortInput != nil && !m.haLoadBalancerPortInput.ValidateInput() {
		valid = false
	}
	if m.haEtcdSnapshotCountInput != nil && !m.haEtcdSnapshotCountInput.ValidateInput() {
		valid = false
	}
	if m.haEtcdHeartbeatInput != nil && !m.haEtcdHeartbeatInput.ValidateInput() {
		valid = false
	}

	// Cross-field network validation
	if valid {
		if err := m.validateNetworkConfiguration(); err != nil {
			valid = false
		}
	}

	return valid
}

func (m ConfigModel) saveConfiguration() error {
	if m.template == nil {
		return fmt.Errorf("no template loaded")
	}

	// Start with the loaded template
	config := *m.template

	// Apply customizations
	if m.clusterNameInput != nil {
		config.Cluster.Name = m.clusterNameInput.GetValue()
	}

	if m.networkSubnetInput != nil {
		config.Network.Subnet = m.networkSubnetInput.GetValue()
	}

	if m.gatewayInput != nil {
		config.Network.Gateway = m.gatewayInput.GetValue()
	}

	if m.podCIDRInput != nil {
		config.Network.PodCIDR = m.podCIDRInput.GetValue()
	}

	if m.serviceCIDRInput != nil {
		config.Network.ServiceCIDR = m.serviceCIDRInput.GetValue()
	}

	if m.dnsDomainInput != nil {
		config.Network.DNS.Domain = m.dnsDomainInput.GetValue()
	}

	if m.dnsUpstreamsInput != nil {
		// Parse comma-separated DNS upstreams back to []string
		upstreamsStr := m.dnsUpstreamsInput.GetValue()
		if upstreamsStr != "" {
			upstreams := strings.Split(upstreamsStr, ",")
			for i, upstream := range upstreams {
				upstreams[i] = strings.TrimSpace(upstream)
			}
			// Filter out empty strings
			var filteredUpstreams []string
			for _, upstream := range upstreams {
				if upstream != "" {
					filteredUpstreams = append(filteredUpstreams, upstream)
				}
			}
			config.Network.DNS.Upstreams = filteredUpstreams
		}
	}

	// Update auto-deploy bundles based on selections
	var selectedBundles []string
	for _, bundle := range m.availableBundles {
		if toggle, exists := m.bundleToggles[bundle.ID]; exists && toggle.GetValue() {
			selectedBundles = append(selectedBundles, bundle.ID)
		}
	}
	config.Workloads.AutoDeployBundles = selectedBundles

	// Apply SSH configuration
	if m.sshPublicKeyInput != nil {
		config.Nodes.SSH.PublicKeyPath = m.sshPublicKeyInput.GetValue()
	}
	if m.sshPrivateKeyInput != nil {
		config.Nodes.SSH.PrivateKeyPath = m.sshPrivateKeyInput.GetValue()
	}
	if m.sshUsernameInput != nil {
		config.Nodes.SSH.Username = m.sshUsernameInput.GetValue()
	}

	// Apply HA configuration (if available)
	if m.hasHAConfiguration() && m.haEnabledToggle != nil {
		// Initialize HA config if it doesn't exist
		if config.Cluster.HAConfig == nil {
			config.Cluster.HAConfig = &utils.HAConfig{}
		}

		config.Cluster.HAConfig.Enabled = m.haEnabledToggle.GetValue()

		if config.Cluster.HAConfig.Enabled {
			if m.haVirtualIPInput != nil {
				config.Cluster.HAConfig.VirtualIP = m.haVirtualIPInput.GetValue()
			}

			// Initialize load balancer config if needed
			if m.haLoadBalancerTypeSelect != nil {
				if config.Cluster.HAConfig.LoadBalancer == nil {
					config.Cluster.HAConfig.LoadBalancer = &utils.LoadBalancer{}
				}
				config.Cluster.HAConfig.LoadBalancer.Type = m.haLoadBalancerTypeSelect.GetValue()

				if m.haLoadBalancerPortInput != nil && m.haLoadBalancerPortInput.GetValue() != "" {
					if port, err := strconv.Atoi(m.haLoadBalancerPortInput.GetValue()); err == nil {
						config.Cluster.HAConfig.LoadBalancer.Port = port
					}
				}
			}

			// Initialize etcd config if needed
			if (m.haEtcdSnapshotCountInput != nil && m.haEtcdSnapshotCountInput.GetValue() != "") ||
				(m.haEtcdHeartbeatInput != nil && m.haEtcdHeartbeatInput.GetValue() != "") {
				if config.Cluster.HAConfig.EtcdConfig == nil {
					config.Cluster.HAConfig.EtcdConfig = &utils.EtcdConfig{}
				}

				if m.haEtcdSnapshotCountInput != nil && m.haEtcdSnapshotCountInput.GetValue() != "" {
					if count, err := strconv.Atoi(m.haEtcdSnapshotCountInput.GetValue()); err == nil {
						config.Cluster.HAConfig.EtcdConfig.SnapshotCount = count
					}
				}

				if m.haEtcdHeartbeatInput != nil && m.haEtcdHeartbeatInput.GetValue() != "" {
					config.Cluster.HAConfig.EtcdConfig.HeartbeatInterval = m.haEtcdHeartbeatInput.GetValue()
				}
			}
		}
	}

	// Apply storage configuration
	if m.storageDefaultClassSelect != nil {
		config.Storage.DefaultStorageClass = m.storageDefaultClassSelect.GetValue()
	}

	// LocalPath configuration
	if m.localPathEnabledToggle != nil {
		config.Storage.LocalPath.Enabled = m.localPathEnabledToggle.GetValue()
	}

	// Longhorn configuration
	if m.longhornEnabledToggle != nil {
		config.Storage.Longhorn.Enabled = m.longhornEnabledToggle.GetValue()
		if m.longhornEnabledToggle.GetValue() {
			if m.longhornNamespaceInput != nil {
				config.Storage.Longhorn.Namespace = m.longhornNamespaceInput.GetValue()
			}
			if m.longhornReplicaCountInput != nil {
				if count, err := fmt.Sscanf(m.longhornReplicaCountInput.GetValue(), "%d", &config.Storage.Longhorn.ReplicaCount); err == nil && count == 1 {
					// Successfully parsed replica count
				}
			}
			if m.longhornStorageClassInput != nil {
				config.Storage.Longhorn.StorageClass.Name = m.longhornStorageClassInput.GetValue()
			}
			if m.longhornReclaimPolicySelect != nil {
				config.Storage.Longhorn.StorageClass.ReclaimPolicy = m.longhornReclaimPolicySelect.GetValue()
			}
			if m.longhornBackupTargetInput != nil {
				config.Storage.Longhorn.Settings.BackupTarget = m.longhornBackupTargetInput.GetValue()
			}
			if m.longhornDataPathInput != nil {
				config.Storage.Longhorn.Settings.DefaultDataPath = m.longhornDataPathInput.GetValue()
			}
		}
	}

	// NFS configuration
	if m.nfsEnabledToggle != nil {
		config.Storage.NFS.Enabled = m.nfsEnabledToggle.GetValue()
		if m.nfsEnabledToggle.GetValue() {
			if m.nfsNamespaceInput != nil {
				config.Storage.NFS.Namespace = m.nfsNamespaceInput.GetValue()
			}
			if m.nfsBackendStorageInput != nil {
				config.Storage.NFS.BackendStorageClass = m.nfsBackendStorageInput.GetValue()
			}
			if m.nfsStorageSizeInput != nil {
				config.Storage.NFS.StorageSize = m.nfsStorageSizeInput.GetValue()
			}
			if m.nfsStorageClassInput != nil {
				config.Storage.NFS.StorageClass.Name = m.nfsStorageClassInput.GetValue()
			}
		}
	}

	// Add generation metadata
	config.Cluster.Description = "Zero Touch Cluster - TUI Generated"
	if config.Cluster.Version == "" {
		config.Cluster.Version = "1.0.0"
	}

	// Validate configuration against schema before saving
	if validationResult, err := utils.GetValidator().ValidateClusterConfig(&config); err != nil {
		return fmt.Errorf("configuration validation failed: %w", err)
	} else if !validationResult.Valid {
		return fmt.Errorf("configuration is invalid:\n%s", validationResult.FormatErrors())
	}

	// Save to session
	if err := m.session.SaveClusterConfig(&config); err != nil {
		return err
	}

	// Mark step as completed
	return m.session.AddCompletedStep("configuration")
}

// validateNetworkConfiguration performs cross-field network validation
func (m *ConfigModel) validateNetworkConfiguration() error {
	var subnet, gateway, podCIDR, serviceCIDR string

	// Get values from input fields
	if m.networkSubnetInput != nil {
		subnet = m.networkSubnetInput.GetValue()
	}
	if m.gatewayInput != nil {
		gateway = m.gatewayInput.GetValue()
	}
	if m.podCIDRInput != nil {
		podCIDR = m.podCIDRInput.GetValue()
	}
	if m.serviceCIDRInput != nil {
		serviceCIDR = m.serviceCIDRInput.GetValue()
	}

	// Validate gateway is within subnet
	if err := validation.ValidateGatewayInSubnet(gateway, subnet); err != nil {
		return err
	}

	// Validate network overlaps
	if err := validation.ValidateNetworkOverlaps(subnet, podCIDR, serviceCIDR); err != nil {
		return err
	}

	return nil
}

// Storage configuration methods

// initializeStorageFields initializes all storage configuration fields with template values
func (m *ConfigModel) initializeStorageFields() {
	if m.template == nil {
		return
	}

	// Storage class selector - use common storage class names
	storageClasses := []string{"local-path", "longhorn", "nfs-client"}
	m.storageDefaultClassSelect = components.NewSelectField("Default Storage Class", storageClasses, 40)
	m.storageDefaultClassSelect.SetValue(m.template.Storage.DefaultStorageClass)

	// LocalPath configuration
	m.localPathEnabledToggle = components.NewToggleField("Enable LocalPath (built-in k3s storage)", m.template.Storage.LocalPath.Enabled)

	// Longhorn configuration
	m.longhornEnabledToggle = components.NewToggleField("Enable Longhorn (distributed block storage)", m.template.Storage.Longhorn.Enabled)
	m.longhornNamespaceInput = components.NewInputField("Longhorn Namespace", "longhorn-system", 30)
	m.longhornNamespaceInput.SetValue(getStringValueOrDefault(m.template.Storage.Longhorn.Namespace, "longhorn-system"))

	m.longhornReplicaCountInput = components.NewInputField("Replica Count", "3", 10)
	m.longhornReplicaCountInput.SetValue(fmt.Sprintf("%d", getIntValueOrDefault(m.template.Storage.Longhorn.ReplicaCount, 3)))
	m.longhornReplicaCountInput.Validate = validation.ValidateReplicaCount

	m.longhornStorageClassInput = components.NewInputField("Storage Class Name", "longhorn", 30)
	m.longhornStorageClassInput.SetValue(getStringValueOrDefault(m.template.Storage.Longhorn.StorageClass.Name, "longhorn"))

	reclaimPolicies := []string{"Retain", "Delete"}
	m.longhornReclaimPolicySelect = components.NewSelectField("Reclaim Policy", reclaimPolicies, 30)
	m.longhornReclaimPolicySelect.SetValue(getStringValueOrDefault(m.template.Storage.Longhorn.StorageClass.ReclaimPolicy, "Delete"))

	m.longhornBackupTargetInput = components.NewInputField("Backup Target (optional)", "s3://backup-bucket@region/", 50)
	m.longhornBackupTargetInput.SetValue(m.template.Storage.Longhorn.Settings.BackupTarget)

	m.longhornDataPathInput = components.NewInputField("Data Path (optional)", "/var/lib/longhorn", 40)
	m.longhornDataPathInput.SetValue(getStringValueOrDefault(m.template.Storage.Longhorn.Settings.DefaultDataPath, "/var/lib/longhorn"))
	m.longhornDataPathInput.Validate = validation.ValidatePath

	// NFS configuration
	m.nfsEnabledToggle = components.NewToggleField("Enable NFS (shared storage)", m.template.Storage.NFS.Enabled)
	m.nfsNamespaceInput = components.NewInputField("NFS Namespace", "nfs-system", 30)
	m.nfsNamespaceInput.SetValue(getStringValueOrDefault(m.template.Storage.NFS.Namespace, "nfs-system"))

	backendOptions := []string{"local-path", "longhorn"}
	m.nfsBackendStorageInput = components.NewSelectField("Backend Storage Class", backendOptions, 30)
	m.nfsBackendStorageInput.SetValue(getStringValueOrDefault(m.template.Storage.NFS.BackendStorageClass, "local-path"))

	m.nfsStorageSizeInput = components.NewInputField("Storage Size", "10Gi", 20)
	m.nfsStorageSizeInput.SetValue(getStringValueOrDefault(m.template.Storage.NFS.StorageSize, "10Gi"))
	m.nfsStorageSizeInput.Validate = validation.ValidateStorageSize

	m.nfsStorageClassInput = components.NewInputField("NFS Storage Class Name", "nfs-client", 30)
	m.nfsStorageClassInput.SetValue(getStringValueOrDefault(m.template.Storage.NFS.StorageClass.Name, "nfs-client"))
}

// renderStorageConfiguration renders the storage configuration step
func (m ConfigModel) renderStorageConfiguration() string {
	content := strings.Builder{}

	content.WriteString("Storage Configuration\n")
	content.WriteString("====================\n\n")
	content.WriteString("Configure storage providers for your cluster:\n\n")

	// Show storage recommendations
	recommendations := m.getStorageClassRecommendations()
	if len(recommendations) > 0 {
		content.WriteString("üí° Recommendations:\n")
		for _, rec := range recommendations {
			icon := "‚ÑπÔ∏è"
			switch rec.Type {
			case "warning":
				icon = "‚ö†Ô∏è"
			case "suggestion":
				icon = "üí°"
			case "tip":
				icon = "üîß"
			}
			content.WriteString(fmt.Sprintf("%s %s: %s\n", icon, rec.Title, rec.Description))
		}
		content.WriteString("\n")
	}

	// Default storage class
	content.WriteString("Default Storage:\n")
	content.WriteString("----------------\n")
	if m.storageDefaultClassSelect != nil {
		content.WriteString(m.storageDefaultClassSelect.View())
		content.WriteString("\n\n")
	}

	// LocalPath storage
	content.WriteString("LocalPath Storage (Built-in):\n")
	content.WriteString("-----------------------------\n")
	if m.localPathEnabledToggle != nil {
		content.WriteString(m.localPathEnabledToggle.View())
		content.WriteString("\n")
	}
	content.WriteString("Fast local storage, no replication across nodes.\n\n")

	// Longhorn storage
	content.WriteString("Longhorn Storage (Distributed):\n")
	content.WriteString("-------------------------------\n")
	if m.longhornEnabledToggle != nil {
		content.WriteString(m.longhornEnabledToggle.View())
		content.WriteString("\n\n")
	}

	// Show Longhorn details if enabled
	if m.longhornEnabledToggle != nil && m.longhornEnabledToggle.GetValue() {
		if m.longhornNamespaceInput != nil {
			content.WriteString(m.longhornNamespaceInput.View())
			content.WriteString("\n\n")
		}
		if m.longhornReplicaCountInput != nil {
			content.WriteString(m.longhornReplicaCountInput.View())
			content.WriteString("\n\n")
		}
		if m.longhornStorageClassInput != nil {
			content.WriteString(m.longhornStorageClassInput.View())
			content.WriteString("\n\n")
		}
		if m.longhornReclaimPolicySelect != nil {
			content.WriteString(m.longhornReclaimPolicySelect.View())
			content.WriteString("\n\n")
		}
		if m.longhornBackupTargetInput != nil {
			content.WriteString(m.longhornBackupTargetInput.View())
			content.WriteString("\n\n")
		}
		if m.longhornDataPathInput != nil {
			content.WriteString(m.longhornDataPathInput.View())
			content.WriteString("\n\n")
		}
	} else {
		content.WriteString("Replicated block storage with snapshots and backups.\n\n")
	}

	// NFS storage
	content.WriteString("NFS Storage (Shared):\n")
	content.WriteString("--------------------\n")
	if m.nfsEnabledToggle != nil {
		content.WriteString(m.nfsEnabledToggle.View())
		content.WriteString("\n\n")
	}

	// Show NFS details if enabled
	if m.nfsEnabledToggle != nil && m.nfsEnabledToggle.GetValue() {
		if m.nfsNamespaceInput != nil {
			content.WriteString(m.nfsNamespaceInput.View())
			content.WriteString("\n\n")
		}
		if m.nfsBackendStorageInput != nil {
			content.WriteString(m.nfsBackendStorageInput.View())
			content.WriteString("\n\n")
		}
		if m.nfsStorageSizeInput != nil {
			content.WriteString(m.nfsStorageSizeInput.View())
			content.WriteString("\n\n")
		}
		if m.nfsStorageClassInput != nil {
			content.WriteString(m.nfsStorageClassInput.View())
			content.WriteString("\n\n")
		}
	} else {
		content.WriteString("Network File System for shared persistent volumes.\n\n")
	}

	content.WriteString("Storage providers can be enabled or disabled based on your needs.\n")

	// Show validation status
	if validationErr := m.validateStorageClassManagement(); validationErr != nil {
		errorStyle := "üö´ Configuration Issue: " + validationErr.Error()
		content.WriteString("\n" + errorStyle + "\n")
	} else {
		successStyle := "‚úÖ Storage configuration is valid\n"
		content.WriteString("\n" + successStyle)
	}

	return content.String()
}

// getStorageFieldCount returns the number of storage fields currently visible
func (m *ConfigModel) getStorageFieldCount() int {
	count := 2 // Default storage class + LocalPath toggle

	// Longhorn toggle
	count++
	if m.longhornEnabledToggle != nil && m.longhornEnabledToggle.GetValue() {
		count += 6 // Longhorn fields when enabled
	}

	// NFS toggle
	count++
	if m.nfsEnabledToggle != nil && m.nfsEnabledToggle.GetValue() {
		count += 4 // NFS fields when enabled
	}

	return count
}

// focusStorageField focuses on a specific storage field by index
func (m *ConfigModel) focusStorageField(index int) {
	// Clear all focus first
	m.blurAllStorageFields()

	fieldIndex := 0

	// Default storage class
	if fieldIndex == index && m.storageDefaultClassSelect != nil {
		m.storageDefaultClassSelect.Focus()
		return
	}
	fieldIndex++

	// LocalPath toggle
	if fieldIndex == index && m.localPathEnabledToggle != nil {
		m.localPathEnabledToggle.Focus()
		return
	}
	fieldIndex++

	// Longhorn toggle
	if fieldIndex == index && m.longhornEnabledToggle != nil {
		m.longhornEnabledToggle.Focus()
		return
	}
	fieldIndex++

	// Longhorn fields (if enabled)
	if m.longhornEnabledToggle != nil && m.longhornEnabledToggle.GetValue() {
		if fieldIndex == index && m.longhornNamespaceInput != nil {
			m.longhornNamespaceInput.Focus()
			return
		}
		fieldIndex++

		if fieldIndex == index && m.longhornReplicaCountInput != nil {
			m.longhornReplicaCountInput.Focus()
			return
		}
		fieldIndex++

		if fieldIndex == index && m.longhornStorageClassInput != nil {
			m.longhornStorageClassInput.Focus()
			return
		}
		fieldIndex++

		if fieldIndex == index && m.longhornReclaimPolicySelect != nil {
			m.longhornReclaimPolicySelect.Focus()
			return
		}
		fieldIndex++

		if fieldIndex == index && m.longhornBackupTargetInput != nil {
			m.longhornBackupTargetInput.Focus()
			return
		}
		fieldIndex++

		if fieldIndex == index && m.longhornDataPathInput != nil {
			m.longhornDataPathInput.Focus()
			return
		}
		fieldIndex++
	}

	// NFS toggle
	if fieldIndex == index && m.nfsEnabledToggle != nil {
		m.nfsEnabledToggle.Focus()
		return
	}
	fieldIndex++

	// NFS fields (if enabled)
	if m.nfsEnabledToggle != nil && m.nfsEnabledToggle.GetValue() {
		if fieldIndex == index && m.nfsNamespaceInput != nil {
			m.nfsNamespaceInput.Focus()
			return
		}
		fieldIndex++

		if fieldIndex == index && m.nfsBackendStorageInput != nil {
			m.nfsBackendStorageInput.Focus()
			return
		}
		fieldIndex++

		if fieldIndex == index && m.nfsStorageSizeInput != nil {
			m.nfsStorageSizeInput.Focus()
			return
		}
		fieldIndex++

		if fieldIndex == index && m.nfsStorageClassInput != nil {
			m.nfsStorageClassInput.Focus()
			return
		}
		fieldIndex++
	}
}

// updateStorageField updates a specific storage field by index
func (m *ConfigModel) updateStorageField(index int, msg tea.Msg) tea.Cmd {
	fieldIndex := 0

	// Default storage class
	if fieldIndex == index && m.storageDefaultClassSelect != nil {
		return m.storageDefaultClassSelect.Update(msg)
	}
	fieldIndex++

	// LocalPath toggle
	if fieldIndex == index && m.localPathEnabledToggle != nil {
		return m.localPathEnabledToggle.Update(msg)
	}
	fieldIndex++

	// Longhorn toggle
	if fieldIndex == index && m.longhornEnabledToggle != nil {
		return m.longhornEnabledToggle.Update(msg)
	}
	fieldIndex++

	// Longhorn fields (if enabled)
	if m.longhornEnabledToggle != nil && m.longhornEnabledToggle.GetValue() {
		if fieldIndex == index && m.longhornNamespaceInput != nil {
			return m.longhornNamespaceInput.Update(msg)
		}
		fieldIndex++

		if fieldIndex == index && m.longhornReplicaCountInput != nil {
			return m.longhornReplicaCountInput.Update(msg)
		}
		fieldIndex++

		if fieldIndex == index && m.longhornStorageClassInput != nil {
			return m.longhornStorageClassInput.Update(msg)
		}
		fieldIndex++

		if fieldIndex == index && m.longhornReclaimPolicySelect != nil {
			return m.longhornReclaimPolicySelect.Update(msg)
		}
		fieldIndex++

		if fieldIndex == index && m.longhornBackupTargetInput != nil {
			return m.longhornBackupTargetInput.Update(msg)
		}
		fieldIndex++

		if fieldIndex == index && m.longhornDataPathInput != nil {
			return m.longhornDataPathInput.Update(msg)
		}
		fieldIndex++
	}

	// NFS toggle
	if fieldIndex == index && m.nfsEnabledToggle != nil {
		return m.nfsEnabledToggle.Update(msg)
	}
	fieldIndex++

	// NFS fields (if enabled)
	if m.nfsEnabledToggle != nil && m.nfsEnabledToggle.GetValue() {
		if fieldIndex == index && m.nfsNamespaceInput != nil {
			return m.nfsNamespaceInput.Update(msg)
		}
		fieldIndex++

		if fieldIndex == index && m.nfsBackendStorageInput != nil {
			return m.nfsBackendStorageInput.Update(msg)
		}
		fieldIndex++

		if fieldIndex == index && m.nfsStorageSizeInput != nil {
			return m.nfsStorageSizeInput.Update(msg)
		}
		fieldIndex++

		if fieldIndex == index && m.nfsStorageClassInput != nil {
			return m.nfsStorageClassInput.Update(msg)
		}
		fieldIndex++
	}

	return nil
}

// blurAllStorageFields removes focus from all storage fields
func (m *ConfigModel) blurAllStorageFields() {
	if m.storageDefaultClassSelect != nil {
		m.storageDefaultClassSelect.Blur()
	}
	if m.localPathEnabledToggle != nil {
		m.localPathEnabledToggle.Blur()
	}
	if m.longhornEnabledToggle != nil {
		m.longhornEnabledToggle.Blur()
	}
	if m.longhornNamespaceInput != nil {
		m.longhornNamespaceInput.Blur()
	}
	if m.longhornReplicaCountInput != nil {
		m.longhornReplicaCountInput.Blur()
	}
	if m.longhornStorageClassInput != nil {
		m.longhornStorageClassInput.Blur()
	}
	if m.longhornReclaimPolicySelect != nil {
		m.longhornReclaimPolicySelect.Blur()
	}
	if m.longhornBackupTargetInput != nil {
		m.longhornBackupTargetInput.Blur()
	}
	if m.longhornDataPathInput != nil {
		m.longhornDataPathInput.Blur()
	}
	if m.nfsEnabledToggle != nil {
		m.nfsEnabledToggle.Blur()
	}
	if m.nfsNamespaceInput != nil {
		m.nfsNamespaceInput.Blur()
	}
	if m.nfsBackendStorageInput != nil {
		m.nfsBackendStorageInput.Blur()
	}
	if m.nfsStorageSizeInput != nil {
		m.nfsStorageSizeInput.Blur()
	}
	if m.nfsStorageClassInput != nil {
		m.nfsStorageClassInput.Blur()
	}
}

// validateStorageConfiguration validates storage provider configuration
func (m *ConfigModel) validateStorageConfiguration() bool {
	// At least one storage provider must be enabled
	localPathEnabled := m.localPathEnabledToggle != nil && m.localPathEnabledToggle.GetValue()
	longhornEnabled := m.longhornEnabledToggle != nil && m.longhornEnabledToggle.GetValue()
	nfsEnabled := m.nfsEnabledToggle != nil && m.nfsEnabledToggle.GetValue()

	if !localPathEnabled && !longhornEnabled && !nfsEnabled {
		return false // At least one storage provider must be enabled
	}

	// Validate individual provider fields
	if longhornEnabled {
		if m.longhornReplicaCountInput != nil && !m.longhornReplicaCountInput.ValidateInput() {
			return false
		}
		if m.longhornDataPathInput != nil && !m.longhornDataPathInput.ValidateInput() {
			return false
		}
	}

	if nfsEnabled {
		if m.nfsStorageSizeInput != nil && !m.nfsStorageSizeInput.ValidateInput() {
			return false
		}
	}

	// Perform cross-provider storage validation
	if err := m.validateStorageClassManagement(); err != nil {
		// Set error on relevant field (for now, we'll just return false)
		// In a more sophisticated UI, we'd show the specific error
		return false
	}

	return true
}


// Helper functions for template values

func getStringValueOrDefault(value, defaultValue string) string {
	if value == "" {
		return defaultValue
	}
	return value
}

func getIntValueOrDefault(value, defaultValue int) int {
	if value == 0 {
		return defaultValue
	}
	return value
}

// Advanced storage validation and management

// validateStorageClassManagement performs cross-provider storage class validation
func (m *ConfigModel) validateStorageClassManagement() error {
	// Get enabled providers and their configurations
	localPathEnabled := m.localPathEnabledToggle != nil && m.localPathEnabledToggle.GetValue()
	longhornEnabled := m.longhornEnabledToggle != nil && m.longhornEnabledToggle.GetValue()
	nfsEnabled := m.nfsEnabledToggle != nil && m.nfsEnabledToggle.GetValue()

	// Collect all storage class names to check for conflicts
	storageClasses := make(map[string]string) // class name -> provider

	// Built-in storage classes
	if localPathEnabled {
		storageClasses["local-path"] = "LocalPath"
	}

	// Longhorn storage classes
	if longhornEnabled && m.longhornStorageClassInput != nil {
		longhornClassName := m.longhornStorageClassInput.GetValue()
		if longhornClassName != "" {
			if existingProvider, exists := storageClasses[longhornClassName]; exists {
				return fmt.Errorf("storage class '%s' conflicts between %s and Longhorn", longhornClassName, existingProvider)
			}
			storageClasses[longhornClassName] = "Longhorn"
		}
	}

	// NFS storage classes
	if nfsEnabled && m.nfsStorageClassInput != nil {
		nfsClassName := m.nfsStorageClassInput.GetValue()
		if nfsClassName != "" {
			if existingProvider, exists := storageClasses[nfsClassName]; exists {
				return fmt.Errorf("storage class '%s' conflicts between %s and NFS", nfsClassName, existingProvider)
			}
			storageClasses[nfsClassName] = "NFS"
		}
	}

	// Validate default storage class exists
	if m.storageDefaultClassSelect != nil {
		defaultClass := m.storageDefaultClassSelect.GetValue()
		if defaultClass != "" {
			if _, exists := storageClasses[defaultClass]; !exists {
				return fmt.Errorf("default storage class '%s' is not provided by any enabled storage provider", defaultClass)
			}
		}
	}

	// Validate NFS backend storage class dependency
	if nfsEnabled && m.nfsBackendStorageInput != nil {
		backendClass := m.nfsBackendStorageInput.GetValue()
		if backendClass != "" {
			if _, exists := storageClasses[backendClass]; !exists {
				return fmt.Errorf("NFS backend storage class '%s' is not available from enabled providers", backendClass)
			}

			// Check for circular dependency
			nfsClassName := ""
			if m.nfsStorageClassInput != nil {
				nfsClassName = m.nfsStorageClassInput.GetValue()
			}
			if backendClass == nfsClassName {
				return fmt.Errorf("NFS backend storage class cannot be the same as NFS storage class (circular dependency)")
			}
		}
	}

	// Validate Longhorn replica count against available nodes
	if longhornEnabled && m.longhornReplicaCountInput != nil {
		replicaCountStr := m.longhornReplicaCountInput.GetValue()
		if replicaCount, err := validation.ParseReplicaCount(replicaCountStr); err == nil {
			// Get node count from template
			availableNodes := m.getAvailableNodeCount()
			if replicaCount > availableNodes {
				return fmt.Errorf("Longhorn replica count (%d) exceeds available nodes (%d)", replicaCount, availableNodes)
			}
		}
	}

	// Validate storage provider combinations
	if err := m.validateStorageProviderCombinations(localPathEnabled, longhornEnabled, nfsEnabled); err != nil {
		return err
	}

	return nil
}

// validateStorageProviderCombinations checks for valid provider combinations
func (m *ConfigModel) validateStorageProviderCombinations(localPath, longhorn, nfs bool) error {
	// Longhorn requires at least 3 nodes for production use
	if longhorn {
		availableNodes := m.getAvailableNodeCount()
		if availableNodes < 3 {
			return fmt.Errorf("Longhorn requires at least 3 nodes for reliable operation (current: %d nodes)", availableNodes)
		}
	}

	// NFS requires a backend storage provider
	if nfs && !localPath && !longhorn {
		return fmt.Errorf("NFS requires a backend storage provider (LocalPath or Longhorn)")
	}

	// Validate storage size requirements
	if nfs && m.nfsStorageSizeInput != nil {
		nfsSize := m.nfsStorageSizeInput.GetValue()
		if err := validation.ValidateStorageCapacity(nfsSize); err != nil {
			return fmt.Errorf("NFS storage size validation failed: %w", err)
		}
	}

	return nil
}

// getAvailableNodeCount returns the number of cluster nodes
func (m *ConfigModel) getAvailableNodeCount() int {
	if m.template == nil {
		return 1 // Default to 1 if no template
	}
	return len(m.template.Nodes.ClusterNodes)
}


// getStorageClassRecommendations provides intelligent storage class recommendations
func (m *ConfigModel) getStorageClassRecommendations() []StorageRecommendation {
	var recommendations []StorageRecommendation

	availableNodes := m.getAvailableNodeCount()
	localPathEnabled := m.localPathEnabledToggle != nil && m.localPathEnabledToggle.GetValue()
	longhornEnabled := m.longhornEnabledToggle != nil && m.longhornEnabledToggle.GetValue()
	nfsEnabled := m.nfsEnabledToggle != nil && m.nfsEnabledToggle.GetValue()

	// Recommendations based on node count and enabled providers
	if availableNodes == 1 {
		recommendations = append(recommendations, StorageRecommendation{
			Type:        "info",
			Title:       "Single Node Setup",
			Description: "LocalPath is recommended for single-node clusters. Longhorn requires 3+ nodes.",
			Action:      "Enable LocalPath only",
		})
	} else if availableNodes >= 3 {
		if !longhornEnabled && availableNodes >= 3 {
			recommendations = append(recommendations, StorageRecommendation{
				Type:        "suggestion",
				Title:       "Consider Longhorn",
				Description: "With 3+ nodes, Longhorn provides data replication and high availability.",
				Action:      "Enable Longhorn for production workloads",
			})
		}
	}

	// Storage class conflict warnings
	if longhornEnabled && nfsEnabled {
		longhornClass := ""
		nfsClass := ""
		if m.longhornStorageClassInput != nil {
			longhornClass = m.longhornStorageClassInput.GetValue()
		}
		if m.nfsStorageClassInput != nil {
			nfsClass = m.nfsStorageClassInput.GetValue()
		}
		if longhornClass == nfsClass && longhornClass != "" {
			recommendations = append(recommendations, StorageRecommendation{
				Type:        "warning",
				Title:       "Storage Class Conflict",
				Description: fmt.Sprintf("Both Longhorn and NFS use storage class '%s'", longhornClass),
				Action:      "Use different storage class names",
			})
		}
	}

	// Performance recommendations
	if localPathEnabled && longhornEnabled {
		recommendations = append(recommendations, StorageRecommendation{
			Type:        "tip",
			Title:       "Performance Optimization",
			Description: "Use LocalPath for high-performance workloads, Longhorn for data that needs replication.",
			Action:      "Set appropriate default storage class",
		})
	}

	return recommendations
}

// StorageRecommendation represents a storage configuration recommendation
type StorageRecommendation struct {
	Type        string // "info", "warning", "suggestion", "tip"
	Title       string
	Description string
	Action      string
}

// initializeSSHFields initializes SSH configuration fields with template values
func (m *ConfigModel) initializeSSHFields() {
	if m.template == nil {
		return
	}

	// SSH Public Key Path
	m.sshPublicKeyInput = components.NewInputField("SSH Public Key Path", "~/.ssh/id_ed25519.pub", 50)
	m.sshPublicKeyInput.SetValue(m.template.Nodes.SSH.PublicKeyPath)
	m.sshPublicKeyInput.Validate = validation.ValidateSSHPublicKeyPath

	// SSH Private Key Path
	m.sshPrivateKeyInput = components.NewInputField("SSH Private Key Path", "~/.ssh/id_ed25519", 50)
	m.sshPrivateKeyInput.SetValue(m.template.Nodes.SSH.PrivateKeyPath)
	m.sshPrivateKeyInput.Validate = validation.ValidateSSHPrivateKeyPath

	// SSH Username
	m.sshUsernameInput = components.NewInputField("SSH Username", "ubuntu", 30)
	m.sshUsernameInput.SetValue(m.template.Nodes.SSH.Username)
	m.sshUsernameInput.Validate = validation.ValidateSSHUsername
}


// hasHAConfiguration checks if HA configuration is available (template includes it or user enabled it)
func (m *ConfigModel) hasHAConfiguration() bool {
	return (m.template != nil && m.template.Cluster.HAConfig != nil) ||
		(m.enableHAToggle != nil && m.enableHAToggle.GetValue())
}

// hasHAInTemplate checks if the template originally includes HA configuration
func (m *ConfigModel) hasHAInTemplate() bool {
	return m.template != nil && m.template.Cluster.HAConfig != nil
}

// hasLonghornInTemplate checks if the template originally includes Longhorn configuration
func (m *ConfigModel) hasLonghornInTemplate() bool {
	return m.template != nil && m.template.Storage.Longhorn.Enabled
}

// hasNFSInTemplate checks if the template originally includes NFS configuration
func (m *ConfigModel) hasNFSInTemplate() bool {
	return m.template != nil && m.template.Storage.NFS.Enabled
}

// hasLonghornConfiguration checks if Longhorn is available (template includes it or user enabled it)
func (m *ConfigModel) hasLonghornConfiguration() bool {
	return m.hasLonghornInTemplate() || (m.enableLonghornToggle != nil && m.enableLonghornToggle.GetValue())
}

// hasNFSConfiguration checks if NFS is available (template includes it or user enabled it)
func (m *ConfigModel) hasNFSConfiguration() bool {
	return m.hasNFSInTemplate() || (m.enableNFSToggle != nil && m.enableNFSToggle.GetValue())
}

// getTemplateFeatures returns a formatted string of actual template features
func (m ConfigModel) getTemplateFeatures() string {
	if m.template == nil {
		return "‚Ä¢ Loading template information...\n\n"
	}

	var features []string

	// Core cluster info
	if len(m.template.Nodes.ClusterNodes) > 0 {
		nodeCount := len(m.template.Nodes.ClusterNodes)
		if nodeCount == 1 {
			features = append(features, "‚Ä¢ Single-node Kubernetes cluster")
		} else {
			features = append(features, fmt.Sprintf("‚Ä¢ %d-node Kubernetes cluster", nodeCount))
		}
	}

	// Storage capabilities
	storageTypes := m.getStorageTypesFromTemplate(m.template)
	if len(storageTypes) > 0 {
		features = append(features, fmt.Sprintf("‚Ä¢ Storage: %s", strings.Join(storageTypes, ", ")))
	}

	// Monitoring stack
	if m.template.Components.Monitoring.Enabled {
		features = append(features, "‚Ä¢ Monitoring stack (Prometheus + Grafana)")
	}

	// Git server
	if m.template.Components.Gitea.Enabled {
		features = append(features, "‚Ä¢ Git server with container registry")
	}

	// ArgoCD GitOps
	if m.template.Components.ArgoCD.Enabled {
		features = append(features, "‚Ä¢ GitOps workflow with ArgoCD")
	}

	// Pre-selected bundles
	if len(m.template.Workloads.AutoDeployBundles) > 0 {
		bundleNames := []string{}
		for _, bundleID := range m.template.Workloads.AutoDeployBundles {
			for _, bundle := range m.availableBundles {
				if bundle.ID == bundleID {
					bundleNames = append(bundleNames, bundle.Name)
					break
				}
			}
		}
		if len(bundleNames) > 0 {
			features = append(features, fmt.Sprintf("‚Ä¢ Pre-configured apps: %s", strings.Join(bundleNames, ", ")))
		}
	}

	// Security features
	features = append(features, "‚Ä¢ Automated security and backup systems")

	// DNS domain
	if m.template.Network.DNS.Domain != "" {
		features = append(features, fmt.Sprintf("‚Ä¢ Services accessible at *.%s", m.template.Network.DNS.Domain))
	}

	return strings.Join(features, "\n") + "\n\n"
}

// getStorageTypesFromTemplate extracts enabled storage types from template
func (m *ConfigModel) getStorageTypesFromTemplate(template *utils.ClusterConfig) []string {
	var types []string
	if template.Storage.LocalPath.Enabled {
		types = append(types, "local-path")
	}
	if template.Storage.Longhorn.Enabled {
		types = append(types, "longhorn")
	}
	if template.Storage.NFS.Enabled {
		types = append(types, "nfs")
	}
	return types
}

// initializeHAFields initializes HA configuration fields if template includes HA config or user enables it
func (m *ConfigModel) initializeHAFields() {
	// Initialize HA fields if template has HA config, or if user might enable it
	if !m.hasHAInTemplate() && (m.enableHAToggle == nil || !m.enableHAToggle.GetValue()) {
		return
	}

	// HA Enabled Toggle
	haEnabled := false
	if m.template.Cluster.HAConfig != nil {
		haEnabled = m.template.Cluster.HAConfig.Enabled
	}
	m.haEnabledToggle = components.NewToggleField("Enable High Availability", haEnabled)

	// HA Virtual IP
	virtualIP := "192.168.50.9" // Default VIP
	if m.template.Cluster.HAConfig != nil && m.template.Cluster.HAConfig.VirtualIP != "" {
		virtualIP = m.template.Cluster.HAConfig.VirtualIP
	}
	m.haVirtualIPInput = components.NewInputField("Virtual IP Address", virtualIP, 40)
	m.haVirtualIPInput.SetValue(virtualIP)
	m.haVirtualIPInput.Validate = validation.ValidateVirtualIP

	// HA Load Balancer Type
	lbOptions := []string{"kube-vip", "haproxy", "keepalived"}
	lbType := "kube-vip" // Default
	if m.template.Cluster.HAConfig != nil && m.template.Cluster.HAConfig.LoadBalancer != nil {
		lbType = m.template.Cluster.HAConfig.LoadBalancer.Type
	}
	m.haLoadBalancerTypeSelect = components.NewSelectField("Load Balancer Type", lbOptions, 40)
	m.haLoadBalancerTypeSelect.SetValue(lbType)

	// HA Load Balancer Port (optional)
	lbPort := ""
	if m.template.Cluster.HAConfig != nil && m.template.Cluster.HAConfig.LoadBalancer != nil && m.template.Cluster.HAConfig.LoadBalancer.Port != 0 {
		lbPort = strconv.Itoa(m.template.Cluster.HAConfig.LoadBalancer.Port)
	}
	m.haLoadBalancerPortInput = components.NewInputField("Load Balancer Port (optional)", "6443", 20)
	m.haLoadBalancerPortInput.SetValue(lbPort)
	m.haLoadBalancerPortInput.Validate = validation.ValidateLoadBalancerPort

	// Etcd Snapshot Count (optional)
	snapshotCount := ""
	if m.template.Cluster.HAConfig != nil && m.template.Cluster.HAConfig.EtcdConfig != nil && m.template.Cluster.HAConfig.EtcdConfig.SnapshotCount != 0 {
		snapshotCount = strconv.Itoa(m.template.Cluster.HAConfig.EtcdConfig.SnapshotCount)
	}
	m.haEtcdSnapshotCountInput = components.NewInputField("Etcd Snapshot Count (optional)", "10000", 20)
	m.haEtcdSnapshotCountInput.SetValue(snapshotCount)
	m.haEtcdSnapshotCountInput.Validate = validation.ValidateEtcdSnapshotCount

	// Etcd Heartbeat Interval (optional)
	heartbeat := ""
	if m.template.Cluster.HAConfig != nil && m.template.Cluster.HAConfig.EtcdConfig != nil && m.template.Cluster.HAConfig.EtcdConfig.HeartbeatInterval != "" {
		heartbeat = m.template.Cluster.HAConfig.EtcdConfig.HeartbeatInterval
	}
	m.haEtcdHeartbeatInput = components.NewInputField("Etcd Heartbeat Interval (optional)", "100ms", 20)
	m.haEtcdHeartbeatInput.SetValue(heartbeat)
	m.haEtcdHeartbeatInput.Validate = validation.ValidateEtcdHeartbeatInterval
}

// initializeFeatureToggles initializes toggles for enabling missing configuration sections
func (m *ConfigModel) initializeFeatureToggles() {
	if m.template == nil {
		return
	}

	// Initialize HA enablement toggle if HA is not in template
	if !m.hasHAInTemplate() {
		m.enableHAToggle = components.NewToggleField("Enable High Availability Configuration", false)
	}

	// Initialize storage provider enablement toggles
	if !m.hasLonghornInTemplate() {
		m.enableLonghornToggle = components.NewToggleField("Enable Longhorn Distributed Storage", false)
	}

	if !m.hasNFSInTemplate() {
		m.enableNFSToggle = components.NewToggleField("Enable NFS Shared Storage", false)
	}
}

// Simple Mode Render Functions

func (m ConfigModel) renderEssentials() string {
	content := strings.Builder{}

	headerStyle := lipgloss.NewStyle().
		Foreground(colors.ZtcOrange).
		Bold(true).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(colors.ZtcLightGray).
		Padding(0, 1).
		Margin(0, 0, 1, 0)

	content.WriteString(headerStyle.Render("üöÄ Essentials") + "\n")

	if m.templateMetadata != nil {
		content.WriteString(fmt.Sprintf("Template: %s\n", m.templateMetadata.Name))
		content.WriteString(fmt.Sprintf("Description: %s\n\n", m.templateMetadata.Description))
	}

	if m.clusterNameInput != nil {
		content.WriteString(m.clusterNameInput.View())
		content.WriteString("\n\n")
	}

	content.WriteString("‚úÖ What's included with this template:\n")
	content.WriteString(m.getTemplateFeatures())

	content.WriteString("üí° All other settings will use secure defaults from your selected template.\n")

	return content.String()
}

func (m ConfigModel) renderNetworkEssentials() string {
	content := strings.Builder{}

	content.WriteString("üåê Network Essentials\n")
	content.WriteString("====================\n\n")

	if m.networkSubnetInput != nil {
		content.WriteString(m.networkSubnetInput.View())
		content.WriteString("\n")
	}

	if m.gatewayInput != nil {
		content.WriteString(m.gatewayInput.View())
		content.WriteString("\n\n")
	}

	content.WriteString("üí° Tips:\n")
	content.WriteString("‚Ä¢ Most home networks use 192.168.1.0/24 or 192.168.50.0/24\n")
	content.WriteString("‚Ä¢ Gateway is usually your router IP (e.g., 192.168.1.1)\n")
	content.WriteString("‚Ä¢ Auto-detection will try to guess these values\n\n")

	content.WriteString("Advanced networking (DNS, pod ranges) will use template defaults.\n")

	return content.String()
}

func (m ConfigModel) renderSSHSetup() string {
	content := strings.Builder{}

	content.WriteString("üîë SSH Setup\n")
	content.WriteString("============\n\n")

	if m.sshPublicKeyInput != nil {
		content.WriteString(m.sshPublicKeyInput.View())
		content.WriteString("\n")
	}

	if m.sshPrivateKeyInput != nil {
		content.WriteString(m.sshPrivateKeyInput.View())
		content.WriteString("\n")
	}

	if m.sshUsernameInput != nil {
		content.WriteString(m.sshUsernameInput.View())
		content.WriteString("\n\n")
	}

	content.WriteString("üí° SSH keys are used to securely connect to your cluster nodes.\n")
	content.WriteString("Common locations:\n")
	content.WriteString("‚Ä¢ ~/.ssh/id_ed25519 (recommended)\n")
	content.WriteString("‚Ä¢ ~/.ssh/id_rsa (older standard)\n\n")

	content.WriteString("If you don't have SSH keys, generate them with:\n")
	content.WriteString("ssh-keygen -t ed25519 -C \"your-email@example.com\"\n")

	return content.String()
}

func (m ConfigModel) renderDeployPreview() string {
	content := strings.Builder{}

	content.WriteString("üöÄ Ready to Deploy!\n")
	content.WriteString("===================\n\n")

	if m.templateMetadata != nil {
		content.WriteString(fmt.Sprintf("Template: %s\n", m.templateMetadata.Name))
	}

	if m.clusterNameInput != nil {
		content.WriteString(fmt.Sprintf("Cluster Name: %s\n", m.clusterNameInput.Value))
	}

	if m.networkSubnetInput != nil {
		content.WriteString(fmt.Sprintf("Network: %s\n", m.networkSubnetInput.Value))
	}

	if m.sshUsernameInput != nil {
		content.WriteString(fmt.Sprintf("SSH User: %s\n", m.sshUsernameInput.Value))
	}

	content.WriteString("\n‚úÖ What will be configured automatically:\n")
	content.WriteString("‚Ä¢ Storage: Local path (fast, reliable)\n")
	content.WriteString("‚Ä¢ Applications: Starter bundle (monitoring, dashboard)\n")
	content.WriteString("‚Ä¢ Security: Auto-generated passwords, sealed secrets\n")
	content.WriteString("‚Ä¢ DNS: homelab.lan domain with auto-discovery\n\n")

	content.WriteString("‚è±Ô∏è  Deployment will take approximately 10-15 minutes.\n\n")

	content.WriteString("Press Enter to proceed to USB creation, or use arrow keys to go back and modify settings.\n")

	return content.String()
}

// initializeConfigSteps creates and initializes all configuration step models
func (m *ConfigModel) initializeConfigSteps() {
	m.configSteps = []ConfigStepModel{
		config_steps.NewNetworkModel(),
		config_steps.NewSSHModel(),
		config_steps.NewStorageModel(),
		config_steps.NewHAModel(),
		config_steps.NewBundleModel(),
		config_steps.NewReviewModel(),
	}

	// Initialize each step with session and template
	for _, step := range m.configSteps {
		step.InitWithConfig(m.session, m.template)
	}

	// Set current step to 0
	m.currentStepIdx = 0
}

// validateCurrentStepModel validates the current step using the step's Validate method
func (m *ConfigModel) validateCurrentStepModel() bool {
	if m.currentStepIdx < len(m.configSteps) {
		if err := m.configSteps[m.currentStepIdx].Validate(); err != nil {
			m.currentError = fmt.Errorf("Step validation failed: %w", err)
			return false
		}
		// Apply step changes to template
		if err := m.configSteps[m.currentStepIdx].ApplyToTemplate(m.template); err != nil {
			m.currentError = fmt.Errorf("Failed to apply step configuration: %w", err)
			return false
		}
	}
	return true
}

// validateAllSteps validates all configuration steps
func (m *ConfigModel) validateAllSteps() bool {
	for i, step := range m.configSteps {
		if err := step.Validate(); err != nil {
			m.currentError = fmt.Errorf("Step %d validation failed: %w", i+1, err)
			return false
		}
		// Apply step changes to template
		if err := step.ApplyToTemplate(m.template); err != nil {
			m.currentError = fmt.Errorf("Failed to apply step %d configuration: %w", i+1, err)
			return false
		}
	}
	return true
}

// Stub methods for old render functions to fix compilation
// These will be removed completely in cleanup
func (m *ConfigModel) clusterNameInput() interface{} { return nil }
func (m *ConfigModel) enableHAToggle() interface{} { return nil }
func (m *ConfigModel) networkSubnetInput() interface{} { return nil }
func (m *ConfigModel) gatewayInput() interface{} { return nil }
func (m *ConfigModel) podCIDRInput() interface{} { return nil }
func (m *ConfigModel) serviceCIDRInput() interface{} { return nil }
func (m *ConfigModel) dnsDomainInput() interface{} { return nil }
func (m *ConfigModel) dnsUpstreamsInput() interface{} { return nil }
func (m *ConfigModel) sshPublicKeyInput() interface{} { return nil }
func (m *ConfigModel) sshPrivateKeyInput() interface{} { return nil }
func (m *ConfigModel) sshUsernameInput() interface{} { return nil }
